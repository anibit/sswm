# Website performance testing script
# Copyright 2014 Jon Wolfe/Anibit Technology All rights reserved.
# You may use this script as you see fit, but you may not claim 
# credit for it's authorship. I request, but not require, that you 
# retain the generated copyright notice in it's entirety in any metrics pages
# 
# If you do find this useful, a note to anibit.technology@gmail.com would 
# be greatly appreciated.

#This was originaly wirtten using Python 3.4
#This script is meant to be rude, crude, and obnoxious. It will work for you.

from bottle import route, post, run, template, request, static_file
import datetime
import sqlite3
import json
import minify_json

config = {}

#todo consider using a template for this stuff...
def html_header():
    return '''<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Stupid Simple Website Metrics</title>
        <style>
        table, th, td {
            border: 1px solid black;
        }
        </style>
    </head>
    <body>
    '''
def html_footer():
    return '''
        <br><br>
        <span>Metrics generated by: <br> <strong>Stupid Simple Website Metrics (C)2014 by <a href="http://www.bytecruft.com">Jon Wolfe</a>/
        <a href="https://anibit.com">Anibit Technology LLC</a></strong>
        <br><br>
        See the <a href="http://github/anibit">Project Page on GitHub</a> for more information.
        </span>
        </body>
    </html>
    '''

@route('/')
def root():

    #figure out our parameters
    toTime = request.query.to_time

    if len(toTime) == 0:
        toTime = datetime.datetime.utcnow().strftime("%Y-%m-%d")

    toTimeDate = datetime.datetime.strptime(toTime, "%Y-%m-%d") #kludgy way to strip time by reparsing the date-only string, don't judge

    fromTime = request.query.from_time
    if len(fromTime) == 0:
        fromTime = (toTimeDate - datetime.timedelta(30) ).strftime("%Y-%m-%d")

    fromTimeDate = datetime.datetime.strptime(fromTime, "%Y-%m-%d") #kludgy way to strip time by reparsing the date-only string, don't judge

    #we want up until the last second of the upper bound day, so add some time.
    toTimeDate = toTimeDate + datetime.timedelta(hours = 23, minutes = 59, seconds = 59)

    #figure out any filter values

    filter = request.query.filter
    if len(filter) == 0:
        filterID = -1
    else:
        filterID = int(filter)



    #now do databasey stuff. 
    db_connection = sqlite3.connect(config['db_name'])

    cursor = db_connection.cursor()
    cursor.execute(r"SELECT * FROM jobruns WHERE datetime(date) >= datetime(?) AND datetime(date) <= datetime(?)", (fromTimeDate, toTimeDate))
    runs = cursor.fetchall()

    if filterID >= 0:
        extraFilter = "AND url_id = %s" % filterID
    else:
        extraFilter = ""

    query = "SELECT * FROM timings WHERE run_id IN (%s) %s" % (",".join([str(x[0]) for x in runs]), extraFilter)
    cursor.execute(query)
    timings = cursor.fetchall()

    url_ids = list(set([x[2] for x in timings])) #hack to limit to unique items
    #now get actual urls
    query = "SELECT * FROM urls WHERE id in (%s)" % ",".join([str(x) for x in url_ids])
    cursor.execute(query)

    url_results = cursor.fetchall()

    #massage the data to the form we want it for tables

    urls = dict( [ (x[0], x[1]) for x in url_results ]) #make a dictionary of ids -> url string
    run_dates = dict( [(x[0], x[1]) for x in runs]) # make a dictionary of run ids -> run job time
    timing_data = sorted([ (run_dates[x[1]], urls[x[2]], x[3], x[4]) for x in timings], key = lambda x: x[0])

    chart_timing_data = [ 
                        (url,
                         sorted([(run_dates[t[1]], t[3], t[4]) for t in timings if url_id == t[2]], key = lambda x: x[0])
                         ) 
                         for (url_id, url) in urls.items()]

    #now generate some html to display it.

    url_filter_items = "".join(["<option value=\"" + str(url_id) + "\">"+ url +"</option>" for (url_id, url) in urls.items()])

    result = html_header() + '''
        <form action="/" method="get">
            From: <input name="from_time" type = "date" value="%s"></input>
            To: <input name="to_time" type = "date" value="%s"></input>
            Filter: <select name = "filter">
                <option value="-1">(all urls)</option>
                %s
                </select>
            <input type="submit" Value="refresh"></input>
        </form>
        ''' % (fromTime, toTime, url_filter_items )

    result += template("chart", timings = chart_timing_data)

    if config['display_table']:
        result += template("result_table", timings = timing_data)
    
    result = result +  html_footer()

    return result

@route('/static/<filename:path>')
def route_static_files_cb(filename):
    return static_file(filename, "./static")

def run_server():
    global config
    print ("Anibit website timer results server, (c) 2014 Anibit Technology");
    print ("Reading config...")
    with open("timing_results.config.json") as f:
        minified = minify_json.json_minify(f.read())
        config = json.loads(minified)
    print ("starting server...")
    run(host=config['server_host'], port = config['server_port'], debug=True)


if __name__ == "__main__":
    run_server()
